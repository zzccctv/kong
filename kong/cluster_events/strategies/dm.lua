---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by zzccc.
--- DateTime: 2023/9/1 17:36
---
local utils = require "kong.tools.utils"
local new_tab = require "table.new"
local concat       = table.concat
local fmt          = string.format

local INSERT_QUERY = [[
INSERT INTO cluster_events("id", "node_id", "at", "nbf", "expire_at", "channel", "data")
 VALUES(
 %s,
 %s,
 %s,
 %s,
 CURRENT_TIMESTAMP(3) + %.1f/24/60/60,
 %s,
 %s)
 ]]

local SELECT_INTERVAL_QUERY = [[
SELECT  "id", "node_id", "channel", "data", UNIX_TIMESTAMP("at") as "at", UNIX_TIMESTAMP("nbf") as  "nbf"
FROM cluster_events
   WHERE "channel" IN (%s)
     AND "at" >  FROM_UNIXTIME(%s)
     AND "at" <= %s
ORDER BY "at"
   offset %s
   rows fetch next %s rows only
]]

local SERVER_TIME_QUERY = [[
SELECT CAST(UNIX_TIMESTAMP(CURRENT_TIMESTAMP) AS BIGINT) AS "now"
]]

local _M = {}

local mt = { __index = _M }

function _M.new(db, page_size, event_ttl)
  if type(page_size) ~= "number" then
    error("page_size must be a number", 2)
  end

  local self  = {
    connector = db.connector,
    page_size = page_size,
    event_ttl = event_ttl,
  }

  return setmetatable(self, mt)
end

function _M.should_use_polling()
  return true
end

function _M:insert(node_id, channel, at, data, delay)
  if at then
    at = fmt("FROM_UNIXTIME(%s)",
      self.connector:escape_literal(tonumber(fmt("%.3f", at))))
  else
    at = "CURRENT_TIMESTAMP(3)"
  end

  local nbf
  if delay then
    nbf = fmt("CURRENT_TIMESTAMP(3) + %.1f/24/60/60 ", delay)
  else
    nbf = "NULL"
  end

  local dm_id      = self.connector:escape_literal(utils.uuid())
  local dm_node_id = self.connector:escape_literal(node_id)
  local dm_channel = self.connector:escape_literal(channel)
  local dm_data    = self.connector:escape_literal(data)

  local q = fmt(INSERT_QUERY, dm_id, dm_node_id, at, nbf, self.event_ttl,
    dm_channel, dm_data)

  local res, err = self.connector:query(q)
  if not res then
    return nil, "could not insert invalidation row: " .. err
  end

  return true
end

function _M:select_interval(channels, min_at, max_at)
  local n_chans = #channels
  local p_chans = new_tab(n_chans, 0)

  for i = 1, n_chans do
    p_chans[i] = self.connector:escape_literal(channels[i])
  end

  p_chans = concat(p_chans, ", ")

  local p_minat = self.connector:escape_literal(tonumber(fmt("%.3f", min_at or 0)))
  local p_maxat
  if max_at then
    p_maxat = fmt("FROM_UNIXTIME(%s)",
      self.connector:escape_literal(tonumber(fmt("%.3f", max_at))))
  else
    p_maxat = "CURRENT_TIMESTAMP(3)"
  end

  local query_template = fmt(SELECT_INTERVAL_QUERY, p_chans,
    p_minat,
    p_maxat,
    "%s",
    self.page_size)

  local page = 0
  local last_page
  return function()
    if last_page then
      return nil
    end

    local offset = page * self.page_size
    local q = fmt(query_template, offset)

    local res, err = self.connector:query(q, "read")
    if not res then
      return nil, err
    end

    local len = #res
    if len == 0 then
      return nil
    end

    for i = 1, len do
      if res[i].nbf == null then
        res[i].nbf = nil
      end
    end

    if len < self.page_size then
      last_page = true
    end

    page = page + 1

    return res, err, page
  end
end

function _M:truncate_events()
  return self.connector:query("TRUNCATE cluster_events")
end

function _M:server_time()
  local res, err = self.connector:query(SERVER_TIME_QUERY, "read")
  if res then
    return res[1].now
  end

  return nil, err
end

return _M
